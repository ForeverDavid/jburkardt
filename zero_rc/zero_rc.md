ZERO\_RC\
Nonlinear Equation Solver, Reverse Communication {#zero_rc-nonlinear-equation-solver-reverse-communication align="center"}
================================================

------------------------------------------------------------------------

**ZERO\_RC** is a C++ library which seeks a solution of a scalar
nonlinear equation f(x)=0, using reverse communication (RC), by Richard
Brent.

One of the standard problems in numerical analysis is to determine an
approximate solution to a scalar nonlinear equation of the form f(x)=0.

Reliable and efficient procedures for this task, sometimes called "zero
finders" or "root solvers" are available in many libraries. These
procedures typically require the user to write a sub-procedure to
evaluate the function for any argument x; the form and list of arguments
for this sub-procedure are strictly prescribed by the library procedure.
The user must somehow make this sub-procedure available to the solver,
either by using a fixed name for the sub-procedure, or by passing in the
actual name as an argument.

In many cases, it can be inconvenient to use such a library routine,
because it is inserted between the main user program and the user
function. This means that data defining the function, which might be
chosen in the main program, must then somehow be communicated to the
user function, perhaps by declaring some kind of global memory, or by
sneaking the data through in an extra argument provided by the library
procedure, or by the use of auxilliary data files.

Moreover, the user essentially loses control of the process until the
library procedure returns. It might, however, be the case that the user
could detect important error conditions, or gather useful information,
if the intermediate x values generated by the library procedure were
visible.

If we denote this typical method of interaction between a user and a
library an instance of "forward communication", then there is an
alternative approach, known as "reverse communication", which allows the
user much more freedom in designing the function evaluation, and in
observing and intervening in the iteration that is seeking the solution.

An idealized version of the use of a reverse communication zero finder
might look like this:

            x = initial approximation.
            while ( not satisfied )
              fx = f(x)
              x = root ( x, fx )
            end
          

Here, "not satisfied" might simply be a test of the magnitude of f(x).
But note two things:

-   The function f(x) is evaluated within the main program. The user
    could write an actual procedure to evaluate f(x), but in that case
    the user is free to design the interface to f(x) in any desired way.
    More importantly, the user can evaluate f(x) directly in the main
    program, and has access to all the data in the main program that
    might be needed to evaluate the function;
-   The user sees every iterate x produced by the zero finder. This
    means the user can catch and occasionally correct problems that
    might arise if x goes out of prescribed bounds; the user can print a
    table of the computed values, or plot the sequence of function
    values.

Reverse communication zero finders can be very useful in situations
where the function to be evaluated is actually the outcome of a
complicated process. For instance, if we are seeking an eigenvalue x
that makes the determinant of some matrix zero, then our function
evaluation may require us to form a large matrix and to factor it in
order to evaluate the determinant. This may be cumbersome to do if we
must perform all these operations in a sub-procedure.

Similarly, we might be solving a boundary value problem using the
shooting method, and f(x) might be the deviation at the final time
between the computed and desired boundary values. In that case, a
subprocedure formulation would require us to set up and solve a boundary
value problem repeatedly in an isolated piece of code.

### Licensing: {#licensing align="center"}

The computer code and data files described and made available on this
web page are distributed under [the GNU LGPL
license.](../../txt/gnu_lgpl.txt)

### Languages: {#languages align="center"}

**ZERO\_RC** is available in [a C
version](../../c_src/zero_rc/zero_rc.md) and [a C++
version](../../master/zero_rc/zero_rc.md) and [a FORTRAN90
version](../../f_src/zero_rc/zero_rc.md) and [a MATLAB
version](../../m_src/zero_rc/zero_rc.md) and [a Python
version](../../py_src/zero_rc/zero_rc.md)..

### Related Data and Programs: {#related-data-and-programs align="center"}

[BACKTRACK\_BINARY\_RC](../../master/backtrack_binary_rc/backtrack_binary_rc.md),
a C++ library which carries out a backtrack search for a set of binary
decisions, using reverse communication (RC).

[BISECTION\_RC](../../master/bisection_rc/bisection_rc.md), a C++
library which seeks a solution to the equation F(X)=0 using bisection
within a user-supplied change of sign interval \[A,B\]. The procedure is
written using reverse communication (RC).

[BRENT](../../master/brent/brent.md), a C++ library which contains
routines for finding zeroes or minima of a scalar function of a scalar
variable, without the use of derivative information, including a reverse
communication (RC) option, by Richard Brent.

[CG\_RC](../../master/cg_rc/cg_rc.md), a C++ library which implements
the conjugate gradient (CG) method for solving a positive definite
sparse linear system A\*x=b, using reverse communication (RC).

[LOCAL\_MIN\_RC](../../master/local_min_rc/local_min_rc.md), a C++
library which finds a local minimum of a scalar function of a scalar
variable, without the use of derivative information, using reverse
communication (RC), by Richard Brent.

[ROOT\_RC](../../master/root_rc/root_rc.md), a C++ library which
seeks a solution of a scalar nonlinear equation f(x) = 0, using reverse
communication (RC), by Gaston Gonnet.

[ROOTS\_RC](../../master/roots_rc/roots_rc.md), a C++ library which
seeks a solution of a system of nonlinear equations f(x) = 0, using
reverse communication (RC), by Gaston Gonnet.

[SORT\_RC](../../master/sort_rc/sort_rc.md), a C++ library which can
sort a list of any kind of objects, using reverse communication (RC).

[TEST\_ZERO](../../master/test_zero/test_zero.md), a C++ library
which implements test problems for the solution of a single nonlinear
equation in one variable.

### Reference: {#reference align="center"}

1.  Richard Brent,\
    Algorithms for Minimization without Derivatives,\
    Dover, 2002,\
    ISBN: 0-486-41998-3,\
    LC: QA402.5.B74.
2.  Werner Rheinboldt,\
    Algorithms for finding zeros of a function,\
    UMAP Journal,\
    Volume 2, Number 1, 1981, pages 43-72.

### Source Code: {#source-code align="center"}

-   [zero\_rc.cpp](zero_rc.cpp), the source code.
-   [zero\_rc.hpp](zero_rc.hpp), the include file.

### Examples and Tests: {#examples-and-tests align="center"}

-   [zero\_rc\_prb.cpp](zero_rc_prb.cpp), a sample calling program.
-   [zero\_rc\_prb\_output.txt](zero_rc_prb_output.txt), the output
    file.

### List of Routines: {#list-of-routines align="center"}

-   **TIMESTAMP** prints out the current YMDHMS date as a timestamp.
-   **ZERO\_RC** solves a single nonlinear equation using reverse
    communication.

You can go up one level to [the C++ source codes](../cpp_src.md).

------------------------------------------------------------------------

*Last revised on 04 December 2016.*
