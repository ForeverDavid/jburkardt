HALTON\_ADVANCED\
The Halton Quasi Monte Carlo (QMC) Sequence {#halton_advanced-the-halton-quasi-monte-carlo-qmc-sequence align="center"}
===========================================

------------------------------------------------------------------------

**HALTON\_ADVANCED** is a C++ library which computes elements of a
Halton Quasi Monte Carlo (QMC) sequence.

HALTON\_ADVANCED includes routines to make it easy to manipulate this
computation, to compute the next N entries, to compute a particular
entry, to restart the sequence at a particular point, or to compute
NDIM-dimensional versions of the sequence.

For the most straightforward use, try either

-   **I4\_TO\_HALTON**, for one element of a sequence;
-   **I4\_TO\_HALTON\_SEQUENCE**, for N elements of a sequence;

Both of these routines require explicit input values for all parameters.

For more convenience, there are two related routines with almost no
input arguments:

-   **HALTON**, for one element of a sequence;
-   **HALTON\_SEQUENCE**, for N elements of a sequence;

These routines allow the user to either rely on the default values of
parameters, or to change a few of them by calling appropriate routines.

The NDIM-dimensional Halton sequence is really NDIM separate sequences,
each generated by a particular base.

Routines in this library select elements of a "leaped" subsequence of
the Halton sequence. The subsequence elements are indexed by a quantity
called STEP, which starts at 0. The STEP-th subsequence element is
simply the Halton sequence element with index

            SEED(1:NDIM) + STEP * LEAP(1:NDIM).
          

The arguments that the user may set include:

-   NDIM, the spatial dimension,\
    default: NDIM = 1,\
    required: 1 &lt;= NDIM;
-   STEP, the subsequence index.\
    default: STEP = 0,\
    required: 0 &lt;= STEP.
-   SEED(1:NDIM), the Halton sequence index corresponding to STEP = 0.\
    default: SEED(1:NDIM) = (0, 0, ... 0),\
    required: 0 &lt;= SEED(1:NDIM);
-   LEAP(1:NDIM), the succesive jumps in the Halton sequence.\
    default: LEAP(1:NDIM) = (1, 1, ..., 1).\
    required: 1 &lt;= LEAP(1:NDIM).
-   BASE(1:NDIM), the Halton bases.\
    default: BASE(1:NDIM) = (2, 3, 5, 7, 11... ),\
    required: 1 &lt; BASE(1:NDIM).

The NDIM-dimensional Halton sequence is derived from the 1-dimensional
van der Corput sequence. Each dimension simply uses a different prime
number as the base of the calculation.

The NDIM-dimensional Halton sequence is related to the NDIM+1
dimensional Hammersley sequence of length NMAX. An NDIM+1 dimensional
Hammersley sequence of length NMAX becomes an NDIM-dimensional Halton
sequence by deleting the first dimension. An NDIM dimensional Halton
sequence of NMAX points becomes an NDIM+1 dimensional Hammersley
sequence of length NMAX by prefixing a first coordinate, and setting the
value of this first coordinate to I/NMAX for the I-th entry of the
sequence.

While the Hammersley sequence has better dispersion properties in
technical measures such as the discrepancy, it suffers from the problem
that you must know, beforehand, the number of points you are going to
generate. Thus, if you have computed a Hammersley sequence of length
100, and you want to compute a Hammersley sequence of length 200, you
must discard your current values and start over. By contrast, you can
compute 100 points of a Halton sequence, and then 100 more, and this
will be the same as computing the first 200 points of the Halton
sequence in one calculation.

In low dimensions, the multidimensional Halton sequence quickly "fills
up" the space in a well-distributed pattern. However, for higher
dimensions (such as NDIM = 40) for instance, the initial elements of the
Halton sequence can be very poorly distributed; it is only when N, the
number of sequence elements, is large enough relative to the spatial
dimension, that the sequence is properly behaved. Remedies for this
problem were suggested by Kocis and Whiten.

As an example of the use of Halton sequences, we also use them to
compute "random" points on or in the unit circle in 2D, and the unit
sphere in 3D.

### Licensing: {#licensing align="center"}

The computer code and data files described and made available on this
web page are distributed under [the GNU LGPL
license.](../../txt/gnu_lgpl.txt)

### Languages: {#languages align="center"}

**HALTON\_ADVANCED** is available in [a C++
version](../../master/halton_advanced/halton_advanced.md) and [a
FORTRAN90 version](../../f_src/halton_advanced/halton_advanced.md) and
[a MATLAB version](../../m_src/halton_advanced/halton_advanced.md).

### Related Data and Programs: {#related-data-and-programs align="center"}

[BOX\_BEHNKEN](../../master/box_behnken/box_behnken.md), a C++
library which computes a Box-Behnken design, that is, a set of arguments
to sample the behavior of a function of multiple parameters;

[CVT](../../master/cvt/cvt.md), a C++ library which computes elements
of a Centroidal Voronoi Tessellation.

[FAURE](../../master/faure/faure.md), a C++ library which computes
elements of a Faure quasirandom sequence.

[HALTON](../../master/halton/halton.md), a C++ library which computes
elements of a Halton Quasi Monte Carlo (QMC) sequence, using a simple
interface.

[HALTON\_DATASET](../../master/halton_dataset/halton_dataset.md), a
C++ program which creates a Halton sequence and writes it to a file.

[HAMMERSLEY](../../master/hammersley/hammersley.md), a C++ library
which computes elements of a Hammersley quasirandom sequence.

[HEX\_GRID](../../master/hex_grid/hex_grid.md), a C++ library which
computes elements of a hexagonal grid dataset.

[IHS](../../master/ihs/ihs.md), a C++ library which computes elements
of an improved distributed Latin hypercube dataset.

[LATIN\_CENTER](../../master/latin_center/latin_center.md), a C++
library which computes elements of a Latin Hypercube dataset, choosing
center points.

[LATIN\_EDGE](../../master/latin_edge/latin_edge.md), a C++ library
which computes elements of a Latin Hypercube dataset, choosing edge
points.

[LATIN\_RANDOM](../../master/latin_random/latin_random.md), a C++
library which computes elements of a Latin Hypercube dataset, choosing
points at random.

[LCVT](../../master/lcvt/lcvt.md), a C++ library which computes a
latinized Centroidal Voronoi Tessellation.

[NIEDERREITER2](../../master/niederreiter2/niederreiter2.md), a C++
library which computes elements of a Niederreiter quasirandom sequence
using base 2.

[NORMAL](../../master/normal/normal.md), a C++ library which computes
elements of a sequence of pseudorandom normally distributed values.

[SOBOL](../../master/sobol/sobol.md), a C++ library which computes
Sobol sequences.

[TOMS647](../../f77_src/toms647/toms647.md), a FORTRAN77 library which
is a version of ACM TOMS algorithm 647, for evaluating Faure, Halton and
Sobol quasirandom sequences.

[UNIFORM](../../master/uniform/uniform.md), a C++ library which
computes elements of a uniform pseudorandom sequence.

[VAN\_DER\_CORPUT](../../master/van_der_corput/van_der_corput.md), a
C++ library which computes elements of a 1D van der Corput sequence,
using a simple interface.

### Reference: {#reference align="center"}

1.  John Halton,\
    On the efficiency of certain quasi-random sequences of points in
    evaluating multi-dimensional integrals,\
    Numerische Mathematik,\
    Volume 2, 1960, pages 84-90.
2.  John Halton, GB Smith,\
    Algorithm 247: Radical-Inverse Quasi-Random Point Sequence,\
    Communications of the ACM,\
    Volume 7, 1964, pages 701-702.
3.  Ladislav Kocis, William Whiten,\
    Computational Investigations of Low-Discrepancy Sequences,\
    ACM Transactions on Mathematical Software,\
    Volume 23, Number 2, 1997, pages 266-294.

### Source Code: {#source-code align="center"}

-   [halton\_advanced.cpp](halton_advanced.cpp), the source code.
-   [halton\_advanced.hpp](halton_advanced.hpp), the include file.

### Examples and Tests: {#examples-and-tests align="center"}

-   [halton\_advanced\_prb.cpp](halton_advanced_prb.cpp), a sample
    problem.
-   [halton\_advanced\_prb\_output.txt](halton_advanced_prb_output.txt),
    sample problem output.
-   [halton\_02\_00010.txt](../../datasets/halton/halton_02_00010.txt),
    a sample dataset created by the program.
-   [halton\_02\_00010.png](../../datasets/halton/halton_02_00010.png),
    a PNG image of the dataset.
-   [halton\_02\_00100.txt](../../datasets/halton/halton_02_00100.txt),
    a sample dataset created by the program.
-   [halton\_02\_00100.png](../../datasets/halton/halton_02_00100.png),
    a PNG image of the dataset.

### List of Routines: {#list-of-routines align="center"}

-   **ARC\_COSINE** computes the arc cosine function, with argument
    truncation.
-   **ATAN4** computes the inverse tangent of the ratio Y / X.
-   **DIGIT\_TO\_CH** returns the base 10 digit character corresponding
    to a digit.
-   **GET\_SEED** returns a random seed for the random number generator.
-   **HALHAM\_DIM\_NUM\_CHECK** checks DIM\_NUM for a Halton or
    Hammersley sequence.
-   **HALHAM\_LEAP\_CHECK** checks LEAP for a Halton or Hammersley
    sequence.
-   **HALHAM\_N\_CHECK** checks N for a Halton or Hammersley sequence.
-   **HALHAM\_SEED\_CHECK** checks SEED for a Halton or Hammersley
    sequence.
-   **HALHAM\_STEP\_CHECK** checks STEP for a Halton or Hammersley
    sequence.
-   **HALHAM\_WRITE** writes a Halton or Hammersley dataset to a file.
-   **HALTON** computes the next element in a leaped Halton subsequence.
-   **HALTON\_BASE\_CHECK** checks BASE for a Halton sequence.
-   **HALTON\_BASE\_GET** gets the base vector for a leaped Halton
    subsequence.
-   **HALTON\_BASE\_SET** sets the base vector for a leaped Halton
    subsequence.
-   **HALTON\_LEAP\_GET** gets the leap vector for a leaped Halton
    subsequence.
-   **HALTON\_LEAP\_SET** sets the leap vector for a leaped Halton
    subsequence.
-   **HALTON\_DIM\_NUM\_GET** gets the spatial dimension for a leaped
    Halton subsequence.
-   **HALTON\_DIM\_NUM\_SET** sets the spatial dimension for a leaped
    Halton subsequence.
-   **HALTON\_SEED\_GET** gets the seed vector for a leaped Halton
    subsequence.
-   **HALTON\_SEED\_SET** sets the seed vector for a leaped Halton
    subsequence.
-   **HALTON\_SEQUENCE** computes N elements in an DIM\_NUM-dimensional
    Halton sequence.
-   **HALTON\_STEP\_GET** gets the step for the leaped Halton
    subsequence.
-   **HALTON\_STEP\_SET** sets the step for a leaped Halton subsequence.
-   **I4\_LOG\_10** returns the whole part of the logarithm base 10 of
    an I4.
-   **I4\_MIN** returns the smaller of two I4's.
-   **I4\_TO\_HALTON** computes one element of a leaped Halton
    subsequence.
-   **I4\_TO\_HALTON\_SEQUENCE** computes N elements of a leaped Halton
    subsequence.
-   **I4\_TO\_S** converts an integer to a string.
-   **I4VEC\_TRANSPOSE\_PRINT** prints an I4VEC "transposed".
-   **PRIME** returns any of the first PRIME\_MAX prime numbers.
-   **R8\_EPSILON** returns the R8 roundoff unit.
-   **R8VEC\_DOT\_PRODUCT** returns the dot product of two R8VEC's.
-   **R8VEC\_NORM\_L2** returns the L2 norm of an R8VEC.
-   **S\_LEN\_TRIM** returns the length of a string to the last
    nonblank.
-   **TIMESTAMP** prints the current YMDHMS date as a time stamp.
-   **TIMESTRING** returns the current YMDHMS date as a string.
-   **U1\_TO\_SPHERE\_UNIT\_2D** maps a point in the unit interval onto
    the circle in 2D.
-   **U2\_TO\_BALL\_UNIT\_2D** maps points from the unit box to the unit
    ball in 2D.
-   **U2\_TO\_SPHERE\_UNIT\_3D** maps a point in the unit box to the
    unit sphere in 3D.
-   **U3\_TO\_BALL\_UNIT\_3D** maps points from the unit box to the unit
    ball in 3D.

You can go up one level to [the C++ source codes](../cpp_src.md).

------------------------------------------------------------------------

*Last revised on 20 October 2006.*
